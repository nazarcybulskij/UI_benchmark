"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toInMemoryZip = toInMemoryZip;
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.toArchive = toArchive;
exports.default = void 0;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _extractZip = _interopRequireDefault(require("extract-zip"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _mkdirp = require("../lib/mkdirp");

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

const extract = _bluebird.default.promisify(_extractZip.default);

const open = _bluebird.default.promisify(_yauzl.default.open);

const ZIP_MAGIC = 'PK';

async function extractAllTo(zipFilePath, destDir) {
  return await extract(zipFilePath, {
    dir: destDir
  });
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await (0, _mkdirp.mkdirp)(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await (0, _mkdirp.mkdirp)(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await open(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('close', resolve);
    archive.finalize();
  });
}

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi96aXAuanMiXSwibmFtZXMiOlsiZXh0cmFjdCIsIkIiLCJwcm9taXNpZnkiLCJub2RlRXh0cmFjdCIsIm9wZW4iLCJ5YXV6bCIsIlpJUF9NQUdJQyIsImV4dHJhY3RBbGxUbyIsInppcEZpbGVQYXRoIiwiZGVzdERpciIsImRpciIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJlbnRyeSIsImRzdFBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsImZpbGVOYW1lIiwidGVzdCIsImZzIiwiZXhpc3RzIiwiZGlybmFtZSIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJyZWplY3QiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsIm9wZW5SZWFkU3RyZWFtIiwiZXJyIiwicmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInppcGZpbGUiLCJsYXp5RW50cmllcyIsIm9uIiwicmVzIiwiZXh0cmFjdEVudHJ5VG8iLCJlbWl0IiwicmVhZEVudHJ5IiwidG9Jbk1lbW9yeVppcCIsInNyY1BhdGgiLCJvcHRzIiwiRXJyb3IiLCJpc01ldGVyZWQiLCJlbmNvZGVUb0Jhc2U2NCIsIm1heFNpemUiLCJHaUIiLCJsZXZlbCIsInJlc3VsdEJ1ZmZlcnMiLCJyZXN1bHRCdWZmZXJzU2l6ZSIsInJlc3VsdFdyaXRlU3RyZWFtIiwic3RyZWFtIiwiV3JpdGFibGUiLCJ3cml0ZSIsImJ1ZmZlciIsImVuY29kaW5nIiwibmV4dCIsInB1c2giLCJsZW5ndGgiLCJhcmNoaXZlIiwiemxpYiIsInNyY1NpemUiLCJiYXNlNjRFbmNvZGVyU3RyZWFtIiwiQmFzZTY0RW5jb2RlIiwicmVzdWx0V3JpdGVTdHJlYW1Qcm9taXNlIiwiZSIsInVucGlwZSIsImFib3J0IiwiZGVzdHJveSIsInBvaW50ZXIiLCJhcmNoaXZlU3RyZWFtUHJvbWlzZSIsIm1lc3NhZ2UiLCJ0aW1lciIsIlRpbWVyIiwic3RhcnQiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJkaXJlY3RvcnkiLCJmaWxlIiwibmFtZSIsImJhc2VuYW1lIiwiZmluYWxpemUiLCJsb2ciLCJkZWJ1ZyIsImdldER1cmF0aW9uIiwiYXNTZWNvbmRzIiwidG9GaXhlZCIsIkJ1ZmZlciIsImNvbmNhdCIsImFzc2VydFZhbGlkWmlwIiwiZmlsZVBhdGgiLCJzaXplIiwiZmQiLCJhbGxvYyIsInJlYWQiLCJzaWduYXR1cmUiLCJ0b1N0cmluZyIsImNsb3NlIiwidG9BcmNoaXZlIiwic3JjIiwicGF0dGVybiIsImN3ZCIsImlnbm9yZSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZ2xvYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxPQUFPLEdBQUdDLGtCQUFFQyxTQUFGLENBQVlDLG1CQUFaLENBQWhCOztBQUNBLE1BQU1DLElBQUksR0FBR0gsa0JBQUVDLFNBQUYsQ0FBWUcsZUFBTUQsSUFBbEIsQ0FBYjs7QUFDQSxNQUFNRSxTQUFTLEdBQUcsSUFBbEI7O0FBUUEsZUFBZUMsWUFBZixDQUE2QkMsV0FBN0IsRUFBMENDLE9BQTFDLEVBQW1EO0FBQ2pELFNBQU8sTUFBTVQsT0FBTyxDQUFDUSxXQUFELEVBQWM7QUFBQ0UsSUFBQUEsR0FBRyxFQUFFRDtBQUFOLEdBQWQsQ0FBcEI7QUFDRDs7QUFTRCxlQUFlRSxlQUFmLENBQWdDQyxPQUFoQyxFQUF5Q0MsS0FBekMsRUFBZ0RKLE9BQWhELEVBQXlEO0FBQ3ZELFFBQU1LLE9BQU8sR0FBR0MsY0FBS0MsT0FBTCxDQUFhUCxPQUFiLEVBQXNCSSxLQUFLLENBQUNJLFFBQTVCLENBQWhCOztBQUdBLE1BQUksTUFBTUMsSUFBTixDQUFXTCxLQUFLLENBQUNJLFFBQWpCLENBQUosRUFBZ0M7QUFDOUIsUUFBSSxFQUFDLE1BQU1F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RUFBQUEsWUFBRjtBQUFnQjJCLEVBQUFBLFdBQWhCO0FBQTZCUyxFQUFBQSxhQUE3QjtBQUE0Q2tELEVBQUFBLGNBQTVDO0FBQTREUyxFQUFBQTtBQUE1RCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IG5vZGVFeHRyYWN0IGZyb20gJ2V4dHJhY3QtemlwJztcbmltcG9ydCB5YXV6bCBmcm9tICd5YXV6bCc7XG5pbXBvcnQgYXJjaGl2ZXIgZnJvbSAnYXJjaGl2ZXInO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGVTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IG1rZGlycCB9IGZyb20gJy4uL2xpYi9ta2RpcnAnO1xuaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IGZzIGZyb20gJy4vZnMnO1xuaW1wb3J0IHsgQmFzZTY0RW5jb2RlIH0gZnJvbSAnYmFzZTY0LXN0cmVhbSc7XG5pbXBvcnQgeyB0b1JlYWRhYmxlU2l6ZVN0cmluZywgR2lCIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBUaW1lciBmcm9tICcuL3RpbWluZyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcblxuY29uc3QgZXh0cmFjdCA9IEIucHJvbWlzaWZ5KG5vZGVFeHRyYWN0KTtcbmNvbnN0IG9wZW4gPSBCLnByb21pc2lmeSh5YXV6bC5vcGVuKTtcbmNvbnN0IFpJUF9NQUdJQyA9ICdQSyc7XG5cbi8qKlxuICogRXh0cmFjdCB6aXBmaWxlIHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcEZpbGVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBaSVAgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBbGxUbyAoemlwRmlsZVBhdGgsIGRlc3REaXIpIHtcbiAgcmV0dXJuIGF3YWl0IGV4dHJhY3QoemlwRmlsZVBhdGgsIHtkaXI6IGRlc3REaXJ9KTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgc2luZ2xlIHppcCBlbnRyeSB0byBhIGRpcmVjdG9yeVxuICpcbiAqIEBwYXJhbSB7U3RyZWFtYWJsZX0gemlwRmlsZSBUaGUgc291cmNlIFpJUCBzdHJlYW1cbiAqIEBwYXJhbSB7eWF1emwuWmlwRW50cnl9IGVudHJ5IFRoZSBlbnRyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9leHRyYWN0RW50cnlUbyAoemlwRmlsZSwgZW50cnksIGRlc3REaXIpIHtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkZXN0RGlyLCBlbnRyeS5maWxlTmFtZSk7XG5cbiAgLy8gQ3JlYXRlIGRlc3QgZGlyZWN0b3J5IGlmIGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuICBpZiAoL1xcLyQvLnRlc3QoZW50cnkuZmlsZU5hbWUpKSB7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZHN0UGF0aCkpIHtcbiAgICAgIGF3YWl0IG1rZGlycChkc3RQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgIGF3YWl0IG1rZGlycChwYXRoLmRpcm5hbWUoZHN0UGF0aCkpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgd3JpdGUgc3RyZWFtXG4gIGNvbnN0IHdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW0oZHN0UGF0aCwge2ZsYWdzOiAndyd9KTtcbiAgY29uc3Qgd3JpdGVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyaXRlU3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIHdyaXRlU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHppcFJlYWRTdHJlYW0gYW5kIHBpcGUgZGF0YSB0byB0aGUgd3JpdGUgc3RyZWFtXG4gIC8vIChmb3Igc29tZSBvZGQgcmVhc29uIEIucHJvbWlzaWZ5IGRvZXNuJ3Qgd29yayBvbiB6aXBmaWxlLm9wZW5SZWFkU3RyZWFtLCBpdCBjYXVzZXMgYW4gZXJyb3IgJ2Nsb3NlZCcpXG4gIGNvbnN0IHppcFJlYWRTdHJlYW0gPSBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwRmlsZS5vcGVuUmVhZFN0cmVhbShlbnRyeSwgKGVyciwgcmVhZFN0cmVhbSkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlYWRTdHJlYW0pKTtcbiAgfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcFJlYWRTdHJlYW0ub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pO1xuICB6aXBSZWFkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSB6aXBSZWFkU3RyZWFtIGFuZCB3cml0ZVN0cmVhbSB0byBlbmQgYmVmb3JlIHJldHVybmluZ1xuICByZXR1cm4gYXdhaXQgQi5hbGwoW1xuICAgIHppcFJlYWRTdHJlYW1Qcm9taXNlLFxuICAgIHdyaXRlU3RyZWFtUHJvbWlzZSxcbiAgXSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWmlwRW50cnlcbiAqIEBwcm9wZXJ0eSB7eWF1emwuWmlwRW50cnl9IGVudHJ5IFRoZSBhY3R1YWwgZW50cnkgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGV4dHJhY3RFbnRyeVRvIEFuIGFzeW5jIGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuXG4gKiBUaGlzIHBhcmFtZXRlciBjb250YWlucyB0aGUgZGVzdGluYXRpb24gZm9sZGVyIHBhdGggdG8gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBnb2luZyB0byBleHRyYWN0IHRoZSBlbnRyeS5cbiAqL1xuXG4vKipcbiAqIEdldCBlbnRyaWVzIGZvciBhIHppcCBmb2xkZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkVudHJ5IENhbGxiYWNrIHdoZW4gZW50cnkgaXMgcmVhZC5cbiAqIFRoZSBjYWxsYmFjayBpcyBleHBlY3RlZCB0byBhY2NlcHQgb25lIGFyZ3VtZW50IG9mIFppcEVudHJ5IHR5cGUuXG4gKiBUaGUgaXRlcmF0aW9uIHRocm91Z2ggdGhlIHNvdXJjZSB6aXAgZmlsZSB3aWxsIGJpIHRlcm1pbmF0ZWQgYXMgc29vbiBhc1xuICogdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGVxdWFscyB0byBgZmFsc2VgLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkRW50cmllcyAoemlwRmlsZVBhdGgsIG9uRW50cnkpIHtcbiAgLy8gT3BlbiBhIHppcCBmaWxlIGFuZCBzdGFydCByZWFkaW5nIGVudHJpZXNcbiAgY29uc3QgemlwZmlsZSA9IGF3YWl0IG9wZW4oemlwRmlsZVBhdGgsIHtsYXp5RW50cmllczogdHJ1ZX0pO1xuICBjb25zdCB6aXBSZWFkU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBmaWxlLm9uY2UoJ2VuZCcsIHJlc29sdmUpO1xuICAgIHppcGZpbGUub25jZSgnZXJyb3InLCByZWplY3QpO1xuXG4gICAgLy8gT24gZWFjaCBlbnRyeSwgY2FsbCAnb25FbnRyeScgYW5kIHRoZW4gcmVhZCB0aGUgbmV4dCBlbnRyeVxuICAgIHppcGZpbGUub24oJ2VudHJ5JywgYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBvbkVudHJ5KHtcbiAgICAgICAgZW50cnksXG4gICAgICAgIGV4dHJhY3RFbnRyeVRvOiBhc3luYyAoZGVzdERpcikgPT4gYXdhaXQgX2V4dHJhY3RFbnRyeVRvKHppcGZpbGUsIGVudHJ5LCBkZXN0RGlyKVxuICAgICAgfSk7XG4gICAgICBpZiAocmVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gemlwZmlsZS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XG4gICAgfSk7XG4gIH0pO1xuICB6aXBmaWxlLnJlYWRFbnRyeSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBlbnRyaWVzIHRvIGZpbmlzaCBiZWluZyBpdGVyYXRlZCB0aHJvdWdoXG4gIHJldHVybiBhd2FpdCB6aXBSZWFkU3RyZWFtUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBaaXBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuY29kZVRvQmFzZTY0IFtmYWxzZV0gV2hldGhlciB0byBlbmNvZGVcbiAqIHRoZSByZXN1bHRpbmcgYXJjaGl2ZSB0byBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc01ldGVyZWQgW3RydWVdIFdoZXRoZXIgdG8gbG9nIHRoZSBhY3R1YWxcbiAqIGFyY2hpdmVyIHBlcmZvcm1hbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2l6ZSBbMTA3Mzc0MTgyNF0gVGhlIG1heGltdW0gc2l6ZSBvZlxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIGluIGJ5dGVzLiBUaGlzIGlzIHNldCB0byAxR0IgYnkgZGVmYXVsdCwgYmVjYXVzZVxuICogQXBwaXVtIGxpbWl0cyB0aGUgbWF4aW11bSBIVFRQIGJvZHkgc2l6ZSB0byAxR0IuIEFsc28sIHRoZSBOb2RlSlMgaGVhcFxuICogc2l6ZSBtdXN0IGJlIGVub3VnaCB0byBrZWVwIHRoZSByZXN1bHRpbmcgb2JqZWN0ICh1c3VhbGx5IHRoaXMgc2l6ZSBpc1xuICogbGltaXRlZCB0byAxLjQgR0IpXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGV2ZWwgWzldIFRoZSBjb21wcmVzc2lvbiBsZXZlbC4gVGhlIG1heGltdW1cbiAqIGxldmVsIGlzIDkgKHRoZSBiZXN0IGNvbXByZXNzaW9uLCB3b3JzdCBwZXJmb3JtYW5jZSkuIFRoZSBtaW5pbXVtXG4gKiBjb21wcmVzc2lvbiBsZXZlbCBpcyAwIChubyBjb21wcmVzc2lvbikuXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBjb250ZW50cyBvZiBsb2NhbCBkaXJlY3RvcnkgdG8gYW4gaW4tbWVtb3J5IC56aXAgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1BhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgZm9sZGVyIG9yIGZpbGUgYmVpbmcgemlwcGVkXG4gKiBAcGFyYW0ge1ppcE9wdGlvbnN9IG9wdHMgWmlwcGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBaaXBwZWQgKGFuZCBlbmNvZGVkIGlmIGBlbmNvZGVUb0Jhc2U2NGAgaXMgdHJ1dGh5KVxuICogY29udGVudCBvZiB0aGUgc291cmNlIHBhdGggYXMgbWVtb3J5IGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSByZWFkaW5nIHRoZSBzb3VyY2VcbiAqIG9yIHRoZSBzb3VyY2UgaXMgdG9vIGJpZ1xuICovXG5hc3luYyBmdW5jdGlvbiB0b0luTWVtb3J5WmlwIChzcmNQYXRoLCBvcHRzID0ge30pIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoc3JjUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggZmlsZSBvciBmb2xkZXI6ICR7c3JjUGF0aH1gKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpc01ldGVyZWQgPSB0cnVlLFxuICAgIGVuY29kZVRvQmFzZTY0ID0gZmFsc2UsXG4gICAgbWF4U2l6ZSA9IDEgKiBHaUIsXG4gICAgbGV2ZWwgPSA5LFxuICB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0QnVmZmVycyA9IFtdO1xuICBsZXQgcmVzdWx0QnVmZmVyc1NpemUgPSAwO1xuICAvLyBDcmVhdGUgYSB3cml0YWJsZSBzdHJlYW0gdGhhdCB6aXAgYnVmZmVycyB3aWxsIGJlIHN0cmVhbWVkIHRvXG4gIGNvbnN0IHJlc3VsdFdyaXRlU3RyZWFtID0gbmV3IHN0cmVhbS5Xcml0YWJsZSh7XG4gICAgd3JpdGU6IChidWZmZXIsIGVuY29kaW5nLCBuZXh0KSA9PiB7XG4gICAgICByZXN1bHRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIHJlc3VsdEJ1ZmZlcnNTaXplICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZiAobWF4U2l6ZSA+IDAgJiYgcmVzdWx0QnVmZmVyc1NpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHJlc3VsdFdyaXRlU3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBUaGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGAgK1xuICAgICAgICAgIGBhcmNoaXZlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAke3RvUmVhZGFibGVTaXplU3RyaW5nKG1heFNpemUpfWApKTtcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9LFxuICB9KTtcblxuICAvLyBaaXAgJ3NyY0RpcicgYW5kIHN0cmVhbSBpdCB0byB0aGUgYWJvdmUgd3JpdGFibGUgc3RyZWFtXG4gIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJywge1xuICAgIHpsaWI6IHtsZXZlbH1cbiAgfSk7XG4gIGxldCBzcmNTaXplID0gbnVsbDtcbiAgY29uc3QgYmFzZTY0RW5jb2RlclN0cmVhbSA9IGVuY29kZVRvQmFzZTY0ID8gbmV3IEJhc2U2NEVuY29kZSgpIDogbnVsbDtcbiAgY29uc3QgcmVzdWx0V3JpdGVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc3VsdFdyaXRlU3RyZWFtLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgIGlmIChiYXNlNjRFbmNvZGVyU3RyZWFtKSB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKGJhc2U2NEVuY29kZXJTdHJlYW0pO1xuICAgICAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnVucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmNoaXZlLnVucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gICAgICB9XG4gICAgICBhcmNoaXZlLmFib3J0KCk7XG4gICAgICBhcmNoaXZlLmRlc3Ryb3koKTtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9KTtcbiAgICByZXN1bHRXcml0ZVN0cmVhbS5vbmNlKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBzcmNTaXplID0gYXJjaGl2ZS5wb2ludGVyKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBhcmNoaXZlU3RyZWFtUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhcmNoaXZlLm9uY2UoJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIGFyY2hpdmUub25jZSgnZXJyb3InLCAoZSkgPT4gcmVqZWN0KFxuICAgICAgbmV3IEVycm9yKGBGYWlsZWQgdG8gYXJjaGl2ZSAnJHtzcmNQYXRofSc6ICR7ZS5tZXNzYWdlfWApKSk7XG4gIH0pO1xuICBjb25zdCB0aW1lciA9IGlzTWV0ZXJlZCA/IG5ldyBUaW1lcigpLnN0YXJ0KCkgOiBudWxsO1xuICBpZiAoKGF3YWl0IGZzLnN0YXQoc3JjUGF0aCkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBhcmNoaXZlLmRpcmVjdG9yeShzcmNQYXRoLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgYXJjaGl2ZS5maWxlKHNyY1BhdGgsIHtcbiAgICAgIG5hbWU6IHBhdGguYmFzZW5hbWUoc3JjUGF0aCksXG4gICAgfSk7XG4gIH1cbiAgaWYgKGJhc2U2NEVuY29kZXJTdHJlYW0pIHtcbiAgICBhcmNoaXZlLnBpcGUoYmFzZTY0RW5jb2RlclN0cmVhbSk7XG4gICAgYmFzZTY0RW5jb2RlclN0cmVhbS5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9XG4gIGFyY2hpdmUuZmluYWxpemUoKTtcblxuICAvLyBXYWl0IGZvciB0aGUgc3RyZWFtcyB0byBmaW5pc2hcbiAgYXdhaXQgQi5hbGwoW2FyY2hpdmVTdHJlYW1Qcm9taXNlLCByZXN1bHRXcml0ZVN0cmVhbVByb21pc2VdKTtcblxuICBpZiAodGltZXIpIHtcbiAgICBsb2cuZGVidWcoYFppcHBlZCAke2VuY29kZVRvQmFzZTY0ID8gJ2FuZCBiYXNlNjQtZW5jb2RlZCAnIDogJyd9YCArXG4gICAgICBgJyR7cGF0aC5iYXNlbmFtZShzcmNQYXRoKX0nIGAgK1xuICAgICAgKHNyY1NpemUgPyBgKCR7dG9SZWFkYWJsZVNpemVTdHJpbmcoc3JjU2l6ZSl9KSBgIDogJycpICtcbiAgICAgIGBpbiAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNTZWNvbmRzLnRvRml4ZWQoMyl9cyBgICtcbiAgICAgIGAoY29tcHJlc3Npb24gbGV2ZWw6ICR7bGV2ZWx9KWApO1xuICB9XG4gIC8vIFJldHVybiB0aGUgYXJyYXkgb2YgemlwIGJ1ZmZlcnMgY29uY2F0ZW5hdGVkIGludG8gb25lIGJ1ZmZlclxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXN1bHRCdWZmZXJzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB3aGV0aGVyIHRoZSBnaXZlbiBmaWxlIGlzIGEgdmFsaWQgWklQIGFyY2hpdmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggLSBGdWxsIHBhdGggdG8gdGhlIGZpbGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICovXG5hc3luYyBmdW5jdGlvbiBhc3NlcnRWYWxpZFppcCAoZmlsZVBhdGgpIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cblxuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcbiAgaWYgKHNpemUgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBhdCAnJHtmaWxlUGF0aH0nIGlzIHRvbyBzbWFsbCB0byBiZSBhIFpJUCBhcmNoaXZlYCk7XG4gIH1cbiAgY29uc3QgZmQgPSBhd2FpdCBmcy5vcGVuKGZpbGVQYXRoLCAncicpO1xuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhaSVBfTUFHSUMubGVuZ3RoKTtcbiAgICBhd2FpdCBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIFpJUF9NQUdJQy5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJ1ZmZlci50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoc2lnbmF0dXJlICE9PSBaSVBfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpbGUgc2lnbmF0dXJlICcke3NpZ25hdHVyZX0nIG9mICcke2ZpbGVQYXRofScgYCArXG4gICAgICAgIGBpcyBub3QgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIFpJUCBhcmNoaXZlIHNpZ25hdHVyZSAnJHtaSVBfTUFHSUN9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5jbG9zZShmZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBaaXBDb21wcmVzc2lvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gLSBDb21wcmVzc2lvbiBsZXZlbCBpbiByYW5nZSAwLi45XG4gKiAoZ3JlYXRlciBudW1iZXJzIG1lYW4gYmV0dGVyIGNvbXByZXNzaW9uLCBidXQgbG9uZ2VyIHByb2Nlc3NpbmcgdGltZSlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFppcFNvdXJjZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7IXN0cmluZ30gcGF0dGVybiBbJyoqXFwvKiddIC0gR0xPQiBwYXR0ZXJuIGZvciBjb21wcmVzc2lvblxuICogQHByb3BlcnR5IHshc3RyaW5nfSBjd2QgLSBUaGUgc291cmNlIHJvb3QgZm9sZGVyICh0aGUgcGFyZW50IGZvbGRlciBvZlxuICogdGhlIGRlc3RpbmF0aW9uIGZpbGUgYnkgZGVmYXVsdClcbiAqIEBwcm9wZXJ0eSB7P0FycmF5PHN0cmluZz59IGlnbm9yZSAtIFRoZSBsaXN0IG9mIGlnbm9yZWQgcGF0dGVybnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJjaGl2ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZ2xvYiBwYXR0ZXJuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRzdFBhdGggLSBUaGUgcmVzdWx0aW5nIGFyY2hpdmUgcGF0aFxuICogQHBhcmFtIHtaaXBTb3VyY2VPcHRpb25zfSBzcmMgLSBTb3VyY2Ugb3B0aW9uc1xuICogQHBhcmFtIHtaaXBDb21wcmVzc2lvbk9wdGlvbnN9IG9wdHMgLSBDb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvQXJjaGl2ZSAoZHN0UGF0aCwgc3JjID0ge30sIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbGV2ZWwgPSA5LFxuICB9ID0gb3B0cztcbiAgY29uc3Qge1xuICAgIHBhdHRlcm4gPSAnKiovKicsXG4gICAgY3dkID0gcGF0aC5kaXJuYW1lKGRzdFBhdGgpLFxuICAgIGlnbm9yZSA9IFtdLFxuICB9ID0gc3JjO1xuICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcsIHsgemxpYjogeyBsZXZlbCB9fSk7XG4gIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRzdFBhdGgpO1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFyY2hpdmVcbiAgICAgIC5nbG9iKHBhdHRlcm4sIHtcbiAgICAgICAgY3dkLFxuICAgICAgICBpZ25vcmUsXG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgIC5waXBlKHN0cmVhbSk7XG4gICAgc3RyZWFtXG4gICAgICAub24oJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUoc3RyZWFtKTtcbiAgICAgICAgYXJjaGl2ZS5hYm9ydCgpO1xuICAgICAgICBhcmNoaXZlLmRlc3Ryb3koKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgICBhcmNoaXZlLmZpbmFsaXplKCk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBfZXh0cmFjdEVudHJ5VG8sXG4gIGFzc2VydFZhbGlkWmlwLCB0b0FyY2hpdmUgfTtcbmV4cG9ydCBkZWZhdWx0IHsgZXh0cmFjdEFsbFRvLCByZWFkRW50cmllcywgdG9Jbk1lbW9yeVppcCwgYXNzZXJ0VmFsaWRaaXAsIHRvQXJjaGl2ZSB9O1xuIl0sImZpbGUiOiJsaWIvemlwLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
